---
title: '123'
output: pdf_document
date: "2024-03-10"
---

```{r}
library(ape)  ## generate neighbor joining tree
```

```{r}
# 定义文件路径
ffc <- '/Users/lifushen/Desktop/giana_for_mouse/clean_altogther---DualChainRotationEncodingBL62.txt'
ffm <- '/Users/lifushen/Desktop/giana_for_mouse/clean_altogther---DualChainRotationEncodingBL62.txt_EncodingMatrix.txt'

d1 <- read.table(ffc, header=FALSE, sep='\t', stringsAsFactors = FALSE)
Mat <- read.table(ffm, header=FALSE, sep='\t', stringsAsFactors = FALSE)

# 显示前几行原始数据
head(d1)
head(Mat)

Mat$cdr3_a_b <- paste(Mat$V1, Mat$V2, sep="+")

# 将新列移动到第一列的位置
Mat <- Mat[, c(ncol(Mat), 1:(ncol(Mat)-1))]

# 现在移除原来的V1和V2列
Mat <- Mat[, -c(2, 3)]

# 检查更新后的数据框
head(Mat)

d1$cdr3_a_b <- paste(d1$V1, d1$V2, sep="+")

# 将新列移动到第一列的位置
d1 <- d1[, c(ncol(d1), 1:(ncol(d1)-1))]

# 现在移除原来的V1和V2列
d1 <- d1[, -c(2, 3)]

head(d1)
```

```{r}
Mat=Mat[,c(1:193)]
Mat <- unique(Mat)  # 确保数据框中没有重复行
Mat <- Mat[!duplicated(Mat[,1]), ]  # 保证第一列没有重复的值
rownames(Mat) <- Mat[,1]
print(Mat)

Mat=Mat[,2:193]
print(Mat)

d1=cbind(d1, Mat[d1[,1],])
print(d1)

map=d1[, c(1, 3)]
write.table(map, "map_a_b_M.txt", sep="\t", row.names=FALSE, col.names=TRUE)
```

```{r}
# 计算相关系数矩阵
Mat.cor=cor(t(d1[, 4:195]))
Mat.dist=sqrt(1-Mat.cor)
head(Mat.dist)
write.table(Mat.dist, file = "/Users/lifushen/Desktop/giana_for_mouse/Mat_dist_together_M.txt", quote = FALSE, sep = "\t")
```

```{r}
```

```{r}

```

```{r}

```